#symbol_name "Acuity_FCS_AVI_v0"
#default_volatile
#enable_trace

#define_constant CRLF "\x0D\x0A"
#define_constant MAX_ITEMS 36
#define_constant MAX_ITEMS_PLUS_1 37
#define_constant MAX_SCENES 12
#define_constant MIN_LEVEL 0
#define_constant MAX_LEVEL 100

#define_constant DEFAULT_STEP 5
#define_constant DEFAULT_FADE 0
#define_constant DEFAULT_SCENE_LEVEL 100
#define_constant REPEAT_START_MS 300
#define_constant REPEAT_EVERY_MS 120

#DEFINE_CONSTANT RX_INPUT_SIZE     255    
#DEFINE_CONSTANT RX_BUFFER_SIZE    2048

#DEFINE_CONSTANT LEN_STATUS_CH     15      // "status channel "

// =========== Inputs ===========
digital_input Initialize;
digital_input Poll;              // global poll: channels + links
digital_input Poll_Channels;     // poll channel levels only
digital_input Poll_Links;        // poll link status only
digital_input Debug;
digital_input _SKIP_;
digital_input Channel_Up, Channel_Down;
digital_input _SKIP_;
digital_input AllOn, AllOff;     // Scene 1 all on/off
digital_input Scene_Level_Up, Scene_Level_Down;
digital_input Link_A_B;
digital_input Unlink_A_B;
digital_input Scene[12];

analog_input Channel_ID;
analog_input StepSize;
analog_input MinLevel;
analog_input MaxLevel;
analog_input FadeSeconds;
analog_input Scene_Level;

string_input Room_Letter$[4];
string_input Rx$[255];

// =========== Outputs ===========
string_output Tx$;
digital_output Ok_fb;
digital_output Failed_fb;
digital_output Link_AB_Linked_fb;    // 1 = A/B linked
digital_output Link_AB_Unlinked_fb;  // 1 = A/B not linked

analog_output Scene_Id_fb;
analog_output Scene_Level_fb;
analog_output Channel_Level_fb[36];  // channel levels only

// =========== Globals ===========
string gBuff$[RX_BUFFER_SIZE];
integer gDbg;
integer gChLevel[MAX_ITEMS_PLUS_1];
integer gLastScene;
integer gStep;
integer gMin;
integer gMax;
integer gFade;
integer gSceneLevel;
integer gExpectLinksLine;

// ================= Helpers =================

function SendCmd(string s$)
{
	makestring(Tx$, "%s%s", s$, CRLF);
	if(gDbg)
	{
		Print("AVI TX: %s\r\n", s$);
	}
}

integer_function KeepInRange(integer value, integer lowbound, integer highbound)
{
	if(value < lowbound)
	{
		return (lowbound);
	}
	if(value > highbound)
	{
		return (highbound);
	}
	return (value);
}

string_function BuildCmd(string kind$, integer id, integer level, integer fade, string room$)
{
	string cmd$[64];
	integer val;
	
	val = KeepInRange(level, MIN_LEVEL, MAX_LEVEL);
	makestring(cmd$, "%s %d %d", kind$, id, val);
	
	if(fade > 0)
	{
		makestring(cmd$, "%s %d", cmd$, fade);
	}
	
	if(len(room$) > 0)
	{
		makestring(cmd$, "%s 0 %s", cmd$, room$);
	}
	
	return (cmd$);
}

string_function BuildStatusCmd(string kind$, string selector$, string room$)
{
	string cmd$[64];
	
	makestring(cmd$, "status %s %s", kind$, selector$);
	if(len(room$) > 0)
	{
		makestring(cmd$, "%s 0 %s", cmd$, room$);
	}
	
	return (cmd$);
}

// ================= Polling helpers =================

function PollChannels()
{
	string cmd$[64];
	
	if(len(Room_Letter$) > 0)
	{
		makestring(cmd$, "status channel all 0 %s", Room_Letter$);
	}
	else
	{
		makestring(cmd$, "status channel all");
	}
	SendCmd(cmd$);
}

function PollLinks()
{
	// global link status; we only care about A/B in ParseStatus()
	SendCmd("status links");
}

function PollCmd()
{
	// global "Poll" button does both
	PollChannels();
	PollLinks();
}

// ================= RX Parsing =================

function ParseStatus(string line$)
{
	string rest$[128];
	string token$[8];
	integer sp;
	integer id;
	integer lvl;
	integer idx;
	
	if(line$ = "Ok")
	{
		Ok_fb = 1;
		Failed_fb = 0;
		return;
	}
	
	if(line$ = "Fail")
	{
		Ok_fb = 0;
		Failed_fb = 1;
		return;
	}
	if(gExpectLinksLine)
	{
		gExpectLinksLine = 0;
		
		// If they say explicitly no links
		if(find(line$, "No Links Active") > 0)
		{
			Link_AB_Linked_fb   = 0;
			Link_AB_Unlinked_fb = 1;
		}
		else
		{
			// If "AB" appears in this list, A/B are linked
			if(find(line$, "AB") > 0)
			{
				Link_AB_Linked_fb   = 1;
				Link_AB_Unlinked_fb = 0;
			}
			else
			{
				Link_AB_Linked_fb   = 0;
				Link_AB_Unlinked_fb = 1;
			}
		}
		return;
	}
	
	// ---- Channel status ----
	if(left(line$, LEN_STATUS_CH) = "status channel")
	{
		// strip "status channel "
		rest$ = mid(line$, LEN_STATUS_CH + 1, len(line$) - LEN_STATUS_CH);
		
		// Handle "status channel ALL <lvl1> <lvl2> ..."
		if(left(rest$, 3) = "ALL")
		{
			// skip "ALL "
			rest$ = mid(rest$, 5, len(rest$) - 4);
			idx = 0;
			
			while((len(rest$) > 0) & (idx < MAX_ITEMS))
			{
				idx = idx + 1;
				sp = find(rest$, " ");
				
				if(sp > 0)
				{
					token$ = left(rest$, sp - 1);
					rest$  = mid(rest$, sp + 1, len(rest$) - sp);
				}
				else
				{
					token$ = rest$;
					rest$  = "";
				}
				
				lvl = atoi(token$);
				lvl = KeepInRange(lvl, MIN_LEVEL, MAX_LEVEL);
				
				gChLevel[idx]          = lvl;
				Channel_Level_fb[idx]  = lvl;
			}
		}
		else
		{
			// Handle single-channel response: "status channel <id> <lvl>"
			sp = find(rest$, " ");
			if(sp > 0)
			{
				id  = atoi(left(rest$, sp - 1));
				lvl = atoi(mid(rest$,  sp + 1, len(rest$) - sp));
				
				if((id >= 1) && (id <= MAX_ITEMS))
				{
					lvl = KeepInRange(lvl, MIN_LEVEL, MAX_LEVEL);
					gChLevel[id]          = lvl;
					Channel_Level_fb[id]  = lvl;
				}
			}
		}
		return;
	}
	
}

function ParseRxBuffer()
{
	string line$[256];
	integer pos;
	
	while((pos = find(gBuff$, CRLF)) > 0)
	{
		line$  = left(gBuff$, pos - 1);
		gBuff$ = mid(gBuff$, pos + 2, len(gBuff$) - pos - 1);
		ParseStatus(line$);
	}
}

// ================= Level / Scene Logic =================

function RefreshSettings()
{
	gStep = StepSize;
	gMin  = MinLevel;
	gMax  = MaxLevel;
	gFade = FadeSeconds;
	
	if(gStep <= 0)
	{
		gStep = DEFAULT_STEP;
	}
	if(gMin < MIN_LEVEL)
	{
		gMin = MIN_LEVEL;
	}
	if(gMax <= 0)
	{
		gMax = MAX_LEVEL;
	}
	if(gMax > MAX_LEVEL)
	{
		gMax = MAX_LEVEL;
	}
	if(gFade < 0)
	{
		gFade = DEFAULT_FADE;
	}
	
	// --- Scene level handling ---
	// Only initialize gSceneLevel once (when it is 0),
	// so button adjustments are preserved.
	if(gSceneLevel <= 0)
	{
		gSceneLevel = Scene_Level;
		if(gSceneLevel <= 0)
		{
			gSceneLevel = DEFAULT_SCENE_LEVEL;
		}
	}
	
	gSceneLevel = KeepInRange(gSceneLevel, MIN_LEVEL, MAX_LEVEL);
	Scene_Level_fb = gSceneLevel;
}

function AdjustChannel(integer dir)
{
	integer id; 
	integer lvl;
	
	RefreshSettings();
	
	id = Channel_ID;
	id = KeepInRange(id, 1, MAX_ITEMS);
	
	lvl = gChLevel[id];
	lvl = lvl + (dir * gStep);
	lvl = KeepInRange(lvl, gMin, gMax);
	
	gChLevel[id]          = lvl;
	Channel_Level_fb[id]  = lvl;
	
	SendCmd(BuildCmd("channel", id, lvl, gFade, Room_Letter$));
}

function RepeatChannelUp()
{
	AdjustChannel(1);
	wait(REPEAT_EVERY_MS, ChUpTick)
	{
		RepeatChannelUp();
	}
}

function RepeatChannelDown()
{
	AdjustChannel(-1);
	wait(REPEAT_EVERY_MS, ChDnTick)
	{
		RepeatChannelDown();
	}
}

function ActivateScene(integer sceneId, integer level)
{
	integer sid;
	integer lvl;
	string cmd$[64];
	
	RefreshSettings();
	
	sid = KeepInRange(sceneId, 1, MAX_SCENES);
	
	if(level < 0)
	{
		lvl = 0;
	}
	else if(level > 100)
	{
		lvl = 100;
	}
	else
	{
		lvl = level;
	}
	
	if(len(Room_Letter$) > 0)
	{
		makestring(cmd$, "scene %d %d 0 %s", sid, lvl, Room_Letter$);
	}
	else
	{
		makestring(cmd$, "scene %d %d", sid, lvl);
	}
	
	SendCmd(cmd$);
	gLastScene   = sid;
	Scene_Id_fb  = sid;
}

function AdjustSceneLevel(integer dir)
{
	// Make sure step / min / max are current and gSceneLevel is clamped
	RefreshSettings();
	
	gSceneLevel = gSceneLevel + (dir * gStep);
	gSceneLevel = KeepInRange(gSceneLevel, MIN_LEVEL, MAX_LEVEL);
	
	Scene_Level_fb = gSceneLevel;
	
	// Always treat Scene 1 as the “live” scene this control rides
	ActivateScene(1, gSceneLevel);
}

// ================= Events =================

push Link_A_B
{
	SendCmd("link AB");
}

push Unlink_A_B
{
	SendCmd("unlink AB");
}

push Scene_Level_Up
{
	AdjustSceneLevel(1);
}

push Scene_Level_Down
{
	AdjustSceneLevel(-1);
}

// ---- Channel ramp buttons ----

push Channel_Up
{
	AdjustChannel(1);
	wait(REPEAT_EVERY_MS, ChUpDelay)
	{
		RepeatChannelUp();
	}
}

release Channel_Up
{
	cancelwait(ChUpDelay);
	cancelwait(ChUpTick);
}

push Channel_Down
{
	AdjustChannel(-1);
	wait(REPEAT_EVERY_MS, ChDnDelay)
	{
		RepeatChannelDown();
	}
}

release Channel_Down
{
	cancelwait(ChDnDelay);
	cancelwait(ChDnTick);
}

// ---- Scene 1 All On / All Off ----

push AllOn
{
	ActivateScene(1, 100);
}

push AllOff
{
	ActivateScene(1, 0);
}

// ---- Scene array ----

push Scene
{
	integer idx;
	idx = GetLastModifiedArrayIndex();
	ActivateScene(idx, gSceneLevel);
}

// ---- Poll buttons ----

push Poll
{
	PollCmd();          // channels + links
}

push Poll_Channels
{
	PollChannels();
}

push Poll_Links
{
	PollLinks();
}

// ---- RX handling ----

change Rx$
{
	makestring(gBuff$, "%s%s", gBuff$, Rx$);
	ParseRxBuffer();
}

// ---- Initialize ----

push Initialize
{
	integer i;
	
	gDbg       = 0;
	Ok_fb      = 0;
	Failed_fb  = 0;
	gLastScene = 0;
	
	for(i = 1 to MAX_ITEMS)
	{
		gChLevel[i]         = 0;
		Channel_Level_fb[i] = 0;
	}
	
	Link_AB_Linked_fb   = 0;
	Link_AB_Unlinked_fb = 1;  // default to "not linked"
	
	RefreshSettings();
}
